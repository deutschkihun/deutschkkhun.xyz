---
title: 'Object Oriented Programming (OOP) and Prototype'
date: '2022-11-27'
lastmod: '2022-11-27'
tags: ['oop', 'prototype']
draft: false
summary: '
객체지향 프로그래밍 (줄여서 OOP)는 컴퓨터 중심이 아닌 인간 중심의 프로그래밍 패러다임을 말한다 OOP 는 프로그래밍 기술/언어를 말하는 것이 아니다. 이 포스팅을 끝으로 OOP 를 확실히 하는 계기가 되보자. prototype은 자바스크립트와 같이 클래스 기반언어가 아닌 언어에서 객체지향을 표현하는 방식에 사용되는 방법이다.'
authors: ['default']
---

![tailwind-nextjs-banner](/static/oop-prototype/cover.jpg)

객체지향 프로그래밍 (줄여서 OOP)는 컴퓨터 중심이 아닌 인간 중심의 프로그래밍 패러다임을 말한다 OOP 는 프로그래밍 기술/언어를 말하는 것이 아니다. 이 포스팅을 끝으로 OOP 를 확실히 하는 계기가 되보자.
prototype은 자바스크립트와 같이 클래스 기반언어가 아닌 언어에서 객체지향을 표현하는 방식에 사용되는 방법이다.

## 1. OOP

객체 위주로 설계하고 프로그래밍하는 패더라임 (프로그래밍 언어 아님) / OOP is a paradigm (not a programming language) for object-based software designing and programming.

**장점**

- Reusability
- Easy to debug

**단점**

- 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead 가 발생하게 된다. (overhead = 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 및 메모리)
- However, Objects share state and could trigger unexpected bugs by changing their state (switch case,if statement,loop).

![oop](/static/oop-prototype/oop.png)

각각의 객체는 메시지를 주고 받으면서 서로 의사소통을 하게 된다.

## 2. OOP 관련하여 알아야 할 개념들

- 클래스: 특정범주,카테고리
- 인스턴스: 예시
- 생성자: In object-oriented programming, a constructor is a special method that is used to initialize an object of a class. When an object is created, the constructor is called automatically, and it initializes the object's member variables and other properties. 생성자는 클래스 안의 객체를 초기화 시켜주는 특별한 매소드입니다. 객체가 생성되면 생성자가 자동으로 호출되어 객체의 멤버 변수 및 기타 프로퍼티를 초기화합니다.

## 4. Prototype

자바스크립트의 경우 prototype 기반의 언어로서 클래스 및 상속의 개념이 존재하지 않지만 prototype 을 통해 객체지향을 표현한다.
자바스크립트는 클래스와 상속이라는 개념이 존재하지 않아도 객체를 이용해서 클래스 기반의 언어처럼 속성(attribute) 과 행위(method)를 정의 할 수 있다.

따라서 자바스크립트의 객체만으로도 객체지향 프로그래밍을 구현하는 것이 가능하지만 그럼에도 불구하고 prototype을 이용해서 객체지향 프로그래밍을 구현하는 이유는 무엇일까?

```tsx
function Person(name, company) {
  this.name = name
  this.company = company

  this.getName = function () {
    return this.name
  }

  this.setName = function () {
    this.name = name
  }
}

const lee = new Person('kihun', 'abc')
const kim = new Person('kibeom', 'abc')

console.log(lee)
console.log(kim)
```

예를들어 옆의 생성자함수를 이용해서 객체를 생성한 경우를 보면 아래 2개의 서로다른 객체를 생성된 것을 볼 수 있다. 이 객체들을 콘솔에 찍어보면 아래와 같다.

```tsx
Person {
  name:'kihun'
  company:'abc',
  getName: [Function]
  setName: [Function]
}

Person {
  name:'kibeom'
  company:'abc',
  getName: [Function]
  setName: [Function]
}
```

두 객체들 모두 method 가 같은 것을 사용함에도 불구하고 전부 따로 정의 된 것을 볼 수 있으면 이것은 메모리 낭비를 초래한다. 이러한 문제를 방지하기 위해 prototype을 사용한다. 기존의 객체안에 정의된 메소드(객체 안에서 정의 된 함수)들을 prototype 객체 안에 넣어보겠습니다.

```tsx
function Person(name, company) {
  this.name = name
  this.company = company

  Person.prototype.getName = function () {
    return this.name
  }

  Person.prototype.setName = function () {
    this.name = name
  }
}

const lee = new Person('kihun', 'abc')
const kim = new Person('kibeom', 'abc')

console.log(lee)
console.log(kim)
console.log(kim.__proto__)
```

이런식으로 prototype 객체안에 getname method 와 setname method 를 추가했습니다.
그리고 나서 새롭게 생성된 서로다른 객체들을 콘솔에 찍어보면 이전과는 다른 결과를 얻을 수 있다.

이렇게 prototype을 이용하면 하위 객체들은 상위객체들을 참조하게 됩니다.
새롭게 생성된 lee 객체와 kim 객체는 내부적으로 proto 라는 객체를 내부적으로 가지게 된다.
proto 는 상위객체를 (이 경우에는 function Person 생성자함수 객체) 를 링크하게 되어 메모리 낭비 없이 효율적으로 method 를 사용 할 수 있게 된다.

```tsx
Person {
  name:'kihun'
  company:'abc',
}

Person {
  name:'kibeom'
  company:'abc',
}

Person {getName: [Function], setName:[Function]}
```

이렇게 인스턴스가 부모 객체의 프로토타입으로 감싸진 메소드를 참조하여 사용하는 것을 프로토타입 체이닝 (prototype chaining) 이라고 한다.

## 5. 함수형 프로그래밍 / 패더다임 (functional programming)

- functional programming is a paradigm for function-based software designing and programming.
- Predictable behavior due to immutability and avoids side effects because state is not used

감사합니다.
